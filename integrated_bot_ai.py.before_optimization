#!/usr/bin/env python3
"""
æ•´åˆç‰ˆå®¢æœæœºå™¨äºº - AIå¢å¼ºç‰ˆ
åŒ…å«ï¼š
1. AIå¯¹è¯å¼•å¯¼
2. é•œåƒæœç´¢åŠŸèƒ½
3. è‡ªåŠ¨ç¿»é¡µç¼“å­˜
4. æ™ºèƒ½å»é‡
"""

import asyncio
import logging
import time
import os
import httpx
import anthropic
import json
import sys
from typing import Dict, Optional
from datetime import datetime

# æ·»åŠ è·¯å¾„
sys.path.insert(0, "/home/atai/bot_data")

# Pyrogram imports
from pyrogram import Client as PyrogramClient, filters
from pyrogram.types import Message as PyrogramMessage
from pyrogram.raw.functions.messages import GetBotCallbackAnswer

# Telegram Bot imports
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters as tg_filters
from telegram.ext import ContextTypes

# å¯¼å…¥æ•°æ®åº“
try:
    from database import CacheDatabase
except ImportError:
    CacheDatabase = None
    logging.warning("database.pyæœªæ‰¾åˆ°ï¼Œç¼“å­˜åŠŸèƒ½å°†ç¦ç”¨")

# ================== é…ç½® ==================
API_ID = 24660516
API_HASH = "eae564578880a59c9963916ff1bbbd3a"
SESSION_NAME = "user_session"
BOT_TOKEN = "8426529617:AAHAxzohSMFBAxInzbAVJsZfkB5bHnOyFC4"
TARGET_BOT = "@openaiw_bot"
ADMIN_ID = 7363537082

# AIæœåŠ¡é…ç½®
MAC_API_URL = "http://192.168.9.10:8000"

# æœç´¢å‘½ä»¤åˆ—è¡¨
SEARCH_COMMANDS = ['/topchat', '/search', '/text', '/human']

# æ—¥å¿—é…ç½®
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# åˆå§‹åŒ–Claudeå®¢æˆ·ç«¯
try:
    claude_client = anthropic.Anthropic(
        api_key=os.environ.get('ANTHROPIC_AUTH_TOKEN'),
        base_url=os.environ.get('ANTHROPIC_BASE_URL', 'https://api.anthropic.com')
    )
    logger.info("âœ… Claude APIå®¢æˆ·ç«¯å·²åˆå§‹åŒ–")
except Exception as e:
    logger.error(f"âŒ Claude APIåˆå§‹åŒ–å¤±è´¥: {e}")
    claude_client = None



class IntegratedBotAI:
    """æ•´åˆçš„å®¢æœæœºå™¨äºº - AIå¢å¼ºç‰ˆ"""

    def __init__(self):
        # Botåº”ç”¨
        self.app = None

        # Pyrogramå®¢æˆ·ç«¯ï¼ˆç”¨äºé•œåƒï¼‰
        self.pyrogram_client: Optional[PyrogramClient] = None
        self.target_bot_id: Optional[int] = None

        # æ¶ˆæ¯æ˜ å°„
        self.pyrogram_to_telegram = {}
        self.telegram_to_pyrogram = {}
        self.callback_data_map = {}
        self.user_search_sessions = {}

        # AIä¼šè¯çŠ¶æ€
        self.user_ai_sessions = {}

        # ç¼“å­˜æ•°æ®åº“
        self.cache_db = CacheDatabase() if CacheDatabase else None

    async def setup_pyrogram(self):
        """è®¾ç½®Pyrogramå®¢æˆ·ç«¯"""
        try:
            proxy_config = None
            if os.environ.get('ALL_PROXY'):
                proxy_url = os.environ.get('ALL_PROXY', '').replace('socks5://', '')
                if proxy_url:
                    host, port = proxy_url.split(':')
                    proxy_config = {"scheme": "socks5", "hostname": host, "port": int(port)}

            self.pyrogram_client = PyrogramClient(
                SESSION_NAME, api_id=API_ID, api_hash=API_HASH,
                proxy=proxy_config if proxy_config else None
            )

            await self.pyrogram_client.start()
            logger.info("âœ… Pyrogramå®¢æˆ·ç«¯å·²å¯åŠ¨")

            target = await self.pyrogram_client.get_users(TARGET_BOT)
            self.target_bot_id = target.id
            logger.info(f"âœ… å·²è¿æ¥åˆ°æœç´¢æœºå™¨äºº: {target.username}")

            @self.pyrogram_client.on_message(filters.user(self.target_bot_id))
            async def on_bot_response(_, message: PyrogramMessage):
                await self.handle_search_response(message)

            @self.pyrogram_client.on_edited_message(filters.user(self.target_bot_id))
            async def on_message_edited(_, message: PyrogramMessage):
                await self.handle_search_response(message, is_edit=True)

            return True
        except Exception as e:
            logger.error(f"Pyrogramè®¾ç½®å¤±è´¥: {e}")
            return False

    async def call_ai_service(self, user_id: int, message: str, context: dict = None) -> dict:
        """ç›´æ¥è°ƒç”¨Claude API"""
        if not claude_client:
            logger.error("Claudeå®¢æˆ·ç«¯æœªåˆå§‹åŒ–")
            return {
                "type": "auto",
                "response": "ğŸ‘‹ è¯·ç›´æ¥å‘é€æœç´¢å…³é”®è¯ï¼Œæˆ–ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤:\n\nâ€¢ /search [å…³é”®è¯] - æœç´¢ç¾¤ç»„åç§°\nâ€¢ /text [å…³é”®è¯] - æœç´¢æ¶ˆæ¯å†…å®¹\nâ€¢ /topchat - çƒ­é—¨åˆ†ç±»",
                "confidence": 0.5
            }
        
        try:
            logger.info(f"[ç”¨æˆ· {user_id}] è°ƒç”¨Claude APIå¤„ç†æ¶ˆæ¯: {message}")
            
            username = context.get('username', f'user_{user_id}') if context else f'user_{user_id}'
            first_name = context.get('first_name', '') if context else ''
            
            response = claude_client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=1024,
                messages=[{
                    "role": "user",
                    "content": f"""ä½ æ˜¯Telegramæœç´¢åŠ©æ‰‹Bot (@ktfund_bot)ã€‚

ç”¨æˆ·ä¿¡æ¯ï¼š
- ç”¨æˆ·å: @{username}
- å§“å: {first_name}
- ID: {user_id}

ç”¨æˆ·æ¶ˆæ¯: "{message}"

è¯·åˆ†æç”¨æˆ·æ„å›¾å¹¶æä¾›å‹å¥½çš„å›å¤ã€‚å¯ç”¨çš„æœç´¢å‘½ä»¤ï¼š
- /search [å…³é”®è¯] - æŒ‰ç¾¤ç»„/é¢‘é“åç§°æœç´¢
- /text [å…³é”®è¯] - æŒ‰æ¶ˆæ¯å†…å®¹æœç´¢
- /human [å…³é”®è¯] - æŒ‰ç”¨æˆ·åæœç´¢
- /topchat - æŸ¥çœ‹çƒ­é—¨ç¾¤ç»„ç›®å½•

è¦æ±‚ï¼š
1. ç”¨ä¸­æ–‡å›å¤ï¼ˆé™¤éç”¨æˆ·ç”¨è‹±æ–‡ï¼‰
2. å‹å¥½ã€ç®€æ´ã€æœ‰å¸®åŠ©
3. å¦‚æœæ˜¯æœç´¢éœ€æ±‚ï¼Œå»ºè®®åˆé€‚çš„å‘½ä»¤
4. å¦‚æœæ˜¯æŠ•è¯‰/é—®é¢˜ï¼Œè¡¨ç¤ºç†è§£å¹¶æä¾›å¸®åŠ©
5. ç›´æ¥ç»™å‡ºå›å¤å†…å®¹ï¼Œä¸è¦è§£é‡Šä½ çš„æ€è€ƒè¿‡ç¨‹

ç›´æ¥å›å¤ç”¨æˆ·ï¼š"""
                }]
            )
            
            claude_response = response.content[0].text.strip()
            logger.info(f"[ç”¨æˆ· {user_id}] âœ… Claudeå›å¤æˆåŠŸ")
            
            return {
                "type": "ai",
                "response": claude_response,
                "confidence": 1.0
            }
            
        except Exception as e:
            logger.error(f"[ç”¨æˆ· {user_id}] âŒ Claude APIè°ƒç”¨å¤±è´¥: {e}")
            return {
                "type": "auto",
                "response": "ğŸ‘‹ è¯·ç›´æ¥å‘é€æœç´¢å…³é”®è¯ï¼Œæˆ–ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤:\n\nâ€¢ /search [å…³é”®è¯] - æœç´¢ç¾¤ç»„åç§°\nâ€¢ /text [å…³é”®è¯] - æœç´¢æ¶ˆæ¯å†…å®¹\nâ€¢ /topchat - çƒ­é—¨åˆ†ç±»",
                "confidence": 0.5
            }

    async def handle_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç†/startå‘½ä»¤ - AIå¼•å¯¼æ¨¡å¼"""
        user = update.effective_user
        user_id = user.id

        self.user_ai_sessions[user_id] = {"started_at": datetime.now(), "conversation": []}

        welcome_text = (
            f"ğŸ‘‹ æ‚¨å¥½ {user.first_name}ï¼\n\n"
            "æˆ‘æ˜¯æ™ºèƒ½æœç´¢åŠ©æ‰‹ï¼Œå¯ä»¥å¸®æ‚¨æ‰¾åˆ°Telegramä¸Šçš„ç¾¤ç»„å’Œé¢‘é“ã€‚\n\n"
            "ğŸ” æˆ‘èƒ½åšä»€ä¹ˆï¼š\n"
            "â€¢ æœç´¢ç¾¤ç»„/é¢‘é“\n"
            "â€¢ æœç´¢ç‰¹å®šè¯é¢˜çš„è®¨è®º\n"
            "â€¢ æŸ¥æ‰¾ç”¨æˆ·\n"
            "â€¢ æµè§ˆçƒ­é—¨åˆ†ç±»\n\n"
            "ğŸ’¬ ç›´æ¥å‘Šè¯‰æˆ‘æ‚¨æƒ³æ‰¾ä»€ä¹ˆï¼Œæˆ‘ä¼šå¸®æ‚¨é€‰æ‹©æœ€åˆé€‚çš„æœç´¢æ–¹å¼ï¼"
        )

        keyboard = [
            [InlineKeyboardButton("ğŸ” æœç´¢ç¾¤ç»„", callback_data="quick_search"),
             InlineKeyboardButton("ğŸ“š ä½¿ç”¨æŒ‡å—", callback_data="quick_help")],
            [InlineKeyboardButton("ğŸ”¥ çƒ­é—¨åˆ†ç±»", callback_data="quick_topchat")]
        ]

        await update.message.reply_text(welcome_text, reply_markup=InlineKeyboardMarkup(keyboard))

        # é€šçŸ¥ç®¡ç†å‘˜
        admin_notification = (
            f"ğŸ†• æ–°ç”¨æˆ·è®¿é—® (AIæ¨¡å¼):\n"
            f"ğŸ‘¤ {user.first_name} {user.last_name or ''}\n"
            f"ğŸ†” {user.id}\n"
            f"ğŸ‘¤ @{user.username or 'æ— '}\n"
            f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )
        await context.bot.send_message(chat_id=ADMIN_ID, text=admin_notification)

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç†æ‰€æœ‰æ¶ˆæ¯ - AIæ™ºèƒ½è·¯ç”±"""
        if not update.message or not update.message.text:
            return

        user = update.effective_user
        user_id = user.id
        text = update.message.text
        is_admin = user_id == ADMIN_ID

        if is_admin and update.message.reply_to_message:
            await self.handle_admin_reply(update, context)
            return

        if self.is_search_command(text):
            await self.handle_search_command(update, context)
            return

        await self.handle_ai_conversation(update, context)

    def is_search_command(self, text: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦æ˜¯æœç´¢å‘½ä»¤"""
        return text and text.split()[0] in SEARCH_COMMANDS

    async def handle_ai_conversation(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """AIå¯¹è¯å¤„ç†"""
        user = update.effective_user
        user_id = user.id
        message = update.message.text

        # æ„å»ºä¸Šä¸‹æ–‡ä¿¡æ¯
        user_context = {
            "username": user.username or f"{user.first_name}_{user.id}",
            "first_name": user.first_name,
            "last_name": user.last_name
        }

        ai_response = await self.call_ai_service(user_id, message, user_context)

        if ai_response.get("type") == "auto":
            response_text = ai_response.get("response", "")
            suggested_cmd = ai_response.get("suggested_command")
            keywords = ai_response.get("keywords")

            if suggested_cmd and keywords:
                keyboard = [
                    [InlineKeyboardButton(
                        f"âœ… å¼€å§‹æœç´¢: {suggested_cmd} {keywords}",
                        callback_data=f"exec_{suggested_cmd.replace('/', '')}_{keywords}"[:64]
                    )],
                    [InlineKeyboardButton("âœï¸ ä¿®æ”¹å…³é”®è¯", callback_data="modify_keywords")]
                ]
                await update.message.reply_text(response_text, reply_markup=InlineKeyboardMarkup(keyboard))

                self.user_ai_sessions[user_id] = {
                    "suggested_command": suggested_cmd,
                    "keywords": keywords,
                    "original_message": message
                }
            else:
                await update.message.reply_text(response_text)
        else:
            response_text = ai_response.get("response", "æŠ±æ­‰ï¼Œæˆ‘æ²¡æœ‰ç†è§£æ‚¨çš„éœ€æ±‚ã€‚")
            await update.message.reply_text(response_text)

    async def handle_search_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç†æœç´¢å‘½ä»¤ - å¸¦ç¼“å­˜"""
        user = update.effective_user
        user_id = user.id
        command = update.message.text

        # æå–å‘½ä»¤å’Œå…³é”®è¯
        parts = command.split(maxsplit=1)
        cmd = parts[0]
        keyword = parts[1] if len(parts) > 1 else ""

        # æ£€æŸ¥ç¼“å­˜
        if self.cache_db and keyword:
            cached = self.cache_db.get_cache(cmd, keyword, 1)
            if cached:
                logger.info(f"è¿”å›ç¼“å­˜ç»“æœ: {cmd} {keyword}")
                await update.message.reply_text(
                    f"ğŸ“¦ ä»ç¼“å­˜è¿”å›ç»“æœï¼š\n\n{cached['text'][:4000]}",
                    parse_mode='HTML'
                )
                return

        # é€šçŸ¥ç®¡ç†å‘˜
        admin_notification = (
            f"ğŸ” ç”¨æˆ·æ‰§è¡Œæœç´¢:\n"
            f"ğŸ‘¤ {user.first_name} {user.last_name or ''}\n"
            f"ğŸ†” {user_id}\n"
            f"ğŸ“ {command}\n"
            f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )
        await context.bot.send_message(chat_id=ADMIN_ID, text=admin_notification)

        wait_msg = await update.message.reply_text("ğŸ” æ­£åœ¨æœç´¢ï¼Œè¯·ç¨å€™...")

        self.user_search_sessions[user_id] = {
            'chat_id': update.effective_chat.id,
            'wait_msg_id': wait_msg.message_id,
            'command': cmd,
            'keyword': keyword,
            'timestamp': datetime.now()
        }

        await self.pyrogram_client.send_message(self.target_bot_id, command)
        logger.info(f"æœç´¢: {command}")

    async def handle_search_response(self, message: PyrogramMessage, is_edit: bool = False):
        """å¤„ç†æœç´¢æœºå™¨äººçš„å“åº” - ä¿å­˜åˆ°ç¼“å­˜"""
        try:
            if not self.user_search_sessions:
                return

            user_id = max(self.user_search_sessions.keys(), key=lambda k: self.user_search_sessions[k]['timestamp'])
            session = self.user_search_sessions[user_id]

            text = message.text or message.caption or "æ— ç»“æœ"

            try:
                if message.text and hasattr(message.text, 'html'):
                    text = message.text.html
            except:
                pass

            keyboard = self.convert_keyboard(message)

            if is_edit and message.id in self.pyrogram_to_telegram:
                telegram_msg_id = self.pyrogram_to_telegram[message.id]
                await self.app.bot.edit_message_text(
                    chat_id=session['chat_id'],
                    message_id=telegram_msg_id,
                    text=text[:4000],
                    reply_markup=keyboard,
                    parse_mode='HTML'
                )
            else:
                try:
                    await self.app.bot.delete_message(
                        chat_id=session['chat_id'],
                        message_id=session['wait_msg_id']
                    )
                except:
                    pass

                sent = await self.app.bot.send_message(
                    chat_id=session['chat_id'],
                    text=text[:4000],
                    reply_markup=keyboard,
                    parse_mode='HTML'
                )

                self.pyrogram_to_telegram[message.id] = sent.message_id
                self.telegram_to_pyrogram[sent.message_id] = message.id

                # ä¿å­˜åˆ°ç¼“å­˜
                if self.cache_db and session.get('keyword'):
                    buttons = self.extract_buttons(message)
                    self.cache_db.save_cache(
                        session['command'],
                        session['keyword'],
                        1,  # ç¬¬ä¸€é¡µ
                        text,
                        text,
                        buttons
                    )

        except Exception as e:
            logger.error(f"å¤„ç†æœç´¢å“åº”å¤±è´¥: {e}")

    def convert_keyboard(self, message: PyrogramMessage) -> Optional[InlineKeyboardMarkup]:
        """è½¬æ¢é”®ç›˜"""
        if not message.reply_markup or not message.reply_markup.inline_keyboard:
            return None

        try:
            buttons = []
            for row in message.reply_markup.inline_keyboard:
                button_row = []
                for btn in row:
                    if btn.url:
                        button_row.append(InlineKeyboardButton(text=btn.text, url=btn.url))
                    elif btn.callback_data:
                        callback_id = f"cb_{time.time():.0f}_{len(self.callback_data_map)}"
                        self.callback_data_map[callback_id] = (message.id, btn.callback_data)
                        button_row.append(InlineKeyboardButton(text=btn.text, callback_data=callback_id[:64]))

                if button_row:
                    buttons.append(button_row)

            return InlineKeyboardMarkup(buttons) if buttons else None
        except Exception as e:
            logger.error(f"é”®ç›˜è½¬æ¢å¤±è´¥: {e}")
            return None

    def extract_buttons(self, message: PyrogramMessage) -> list:
        """æå–æŒ‰é’®æ•°æ®"""
        if not message.reply_markup or not message.reply_markup.inline_keyboard:
            return []

        buttons = []
        for row in message.reply_markup.inline_keyboard:
            for btn in row:
                buttons.append({"text": btn.text, "url": btn.url if btn.url else None})
        return buttons

    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç†å›è°ƒæŸ¥è¯¢"""
        query = update.callback_query
        data = query.data

        await query.answer()

        if data == "quick_search":
            await query.message.reply_text("è¯·å‘Šè¯‰æˆ‘æ‚¨æƒ³æœç´¢ä»€ä¹ˆå†…å®¹")
            return
        elif data == "quick_help":
            await query.message.reply_text(
                "ğŸ“– ä½¿ç”¨æŒ‡å—ï¼š\n\n"
                "â€¢ /search [å…³é”®è¯] - æŒ‰ç¾¤ç»„åç§°æœç´¢\n"
                "â€¢ /text [å…³é”®è¯] - æŒ‰æ¶ˆæ¯å†…å®¹æœç´¢\n"
                "â€¢ /human [å…³é”®è¯] - æŒ‰ç”¨æˆ·åæœç´¢\n"
                "â€¢ /topchat - çƒ­é—¨ç¾¤ç»„ç›®å½•"
            )
            return
        elif data == "quick_topchat":
            # åˆ›å»ºå‡updateæ¥æ‰§è¡Œæœç´¢
            from types import SimpleNamespace
            fake_update = SimpleNamespace(
                effective_user=query.from_user,
                effective_chat=query.message.chat,
                message=SimpleNamespace(text='/topchat')
            )
            await self.handle_search_command(fake_update, context)
            return
        elif data.startswith("exec_"):
            parts = data.replace("exec_", "").split("_", 1)
            if len(parts) == 2:
                command, keywords = parts
                search_text = f"/{command} {keywords}"
                from types import SimpleNamespace
                fake_update = SimpleNamespace(
                    effective_user=query.from_user,
                    effective_chat=query.message.chat,
                    message=SimpleNamespace(text=search_text)
                )
                await self.handle_search_command(fake_update, context)
            return

        # ç¿»é¡µcallback
        if data in self.callback_data_map:
            pyrogram_msg_id, original_callback = self.callback_data_map[data]
            try:
                if not isinstance(original_callback, bytes):
                    original_callback = original_callback.encode() if original_callback else b''

                await self.pyrogram_client.invoke(
                    GetBotCallbackAnswer(
                        peer=await self.pyrogram_client.resolve_peer(self.target_bot_id),
                        msg_id=pyrogram_msg_id,
                        data=original_callback
                    )
                )
                await asyncio.sleep(1)
            except Exception as e:
                logger.error(f"Callbackå¤„ç†å¤±è´¥: {e}")

    async def handle_admin_reply(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç†ç®¡ç†å‘˜å›å¤"""
        reply_to = update.message.reply_to_message
        if not reply_to or not reply_to.text:
            return

        import re
        user_id = None
        for line in reply_to.text.split('\n'):
            if 'ğŸ†”' in line or 'ID:' in line:
                numbers = re.findall(r'\d+', line)
                if numbers:
                    user_id = int(numbers[0])
                    break

        if not user_id:
            await update.message.reply_text("âŒ æ— æ³•è¯†åˆ«ç”¨æˆ·ID")
            return

        try:
            await context.bot.send_message(chat_id=user_id, text=update.message.text)
            await update.message.reply_text(f"âœ… å·²å›å¤ç»™ç”¨æˆ· {user_id}")
        except Exception as e:
            await update.message.reply_text(f"âŒ å›å¤å¤±è´¥: {str(e)}")

    async def initialize(self):
        """åˆå§‹åŒ–æœºå™¨äºº"""
        try:
            logger.info("æ­£åœ¨åˆå§‹åŒ–æ•´åˆæœºå™¨äºº...")

            if not await self.setup_pyrogram():
                logger.error("Pyrogramåˆå§‹åŒ–å¤±è´¥")
                return False

            builder = Application.builder().token(BOT_TOKEN)

            if os.environ.get('HTTP_PROXY'):
                proxy_url = os.environ.get('HTTP_PROXY')
                logger.info(f"é…ç½®Telegram Botä»£ç†: {proxy_url}")
                request = httpx.AsyncClient(proxies={"http://": proxy_url, "https://": proxy_url}, timeout=30.0)
                builder = builder.request(request)

            self.app = builder.build()

            self.app.add_handler(CommandHandler("start", self.handle_start))
            self.app.add_handler(CallbackQueryHandler(self.handle_callback))
            self.app.add_handler(MessageHandler(tg_filters.ALL, self.handle_message))

            logger.info("âœ… æ•´åˆæœºå™¨äººåˆå§‹åŒ–å®Œæˆ")
            return True

        except Exception as e:
            logger.error(f"åˆå§‹åŒ–å¤±è´¥: {e}")
            return False

    async def run(self):
        """è¿è¡Œæœºå™¨äºº"""
        try:
            await self.app.initialize()
            await self.app.start()
            await self.app.updater.start_polling(drop_pending_updates=True)

            logger.info("="*50)
            logger.info("âœ… AIå¢å¼ºç‰ˆBotå·²å¯åŠ¨")
            logger.info(f"AIæœåŠ¡: {MAC_API_URL}")
            logger.info(f"ç¼“å­˜åŠŸèƒ½: {'å¯ç”¨' if self.cache_db else 'ç¦ç”¨'}")
            logger.info("="*50)

            await asyncio.Event().wait()

        except KeyboardInterrupt:
            logger.info("æ”¶åˆ°åœæ­¢ä¿¡å·")
        finally:
            await self.cleanup()

    async def cleanup(self):
        """æ¸…ç†èµ„æº"""
        logger.info("æ­£åœ¨æ¸…ç†...")

        if self.app:
            await self.app.updater.stop()
            await self.app.stop()
            await self.app.shutdown()

        if self.pyrogram_client:
            await self.pyrogram_client.stop()

        logger.info("âœ… æ¸…ç†å®Œæˆ")


async def main():
    """ä¸»å‡½æ•°"""
    bot = IntegratedBotAI()

    if await bot.initialize():
        await bot.run()
    else:
        logger.error("åˆå§‹åŒ–å¤±è´¥ï¼Œé€€å‡º")


if __name__ == "__main__":
    asyncio.run(main())
